<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Flappy Shiba</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #1a1a2e;
        overflow: hidden; /* Prevent scrolling on mobile */
        font-family: "Press Start 2P", monospace;
        touch-action: none; /* Disable default touch actions */
      }

      #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: white;
        text-shadow: 2px 2px 0 #000;
      }

      .title {
        font-size: 40px;
        color: #fca311;
        margin-bottom: 20px;
        animation: float 2s ease-in-out infinite;
      }

      .subtitle {
        font-size: 16px;
        color: #e5e5e5;
        line-height: 1.5;
        animation: pulse 1s infinite alternate;
      }

      #score-display {
        position: absolute;
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 48px;
        color: white;
        z-index: 10;
        text-shadow: 3px 3px 0 #000;
        display: none;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      @keyframes pulse {
        from {
          opacity: 0.8;
        }
        to {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div id="score-display">0</div>

    <div id="ui-layer">
      <div id="start-screen">
        <div class="title">FLAPPY SHIBA</div>
        <div class="subtitle">TAP, CLICK, or SPACE<br />TO THE MOON! ðŸš€</div>
      </div>
      <div id="game-over-screen" style="display: none">
        <div class="title" style="color: #ff4d4d">GAME OVER</div>
        <div class="subtitle" id="final-score">Score: 0</div>
        <div class="subtitle" style="margin-top: 20px; font-size: 12px">
          TAP TO RETRY
        </div>
      </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      /**
       * Game Configuration & State
       */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const uiLayer = document.getElementById("ui-layer");
      const startScreen = document.getElementById("start-screen");
      const gameOverScreen = document.getElementById("game-over-screen");
      const scoreDisplay = document.getElementById("score-display");
      const finalScoreText = document.getElementById("final-score");

      let frames = 0;
      let score = 0;
      let highScore = localStorage.getItem("flappyShibaHighScore") || 0;
      let gameSpeed = 3;
      let state = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2,
      };

      // Resize handling
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      /**
       * Audio (Synthesized for simplicity)
       */
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      function playSound(type) {
        if (audioCtx.state === "suspended") audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === "jump") {
          osc.type = "square";
          osc.frequency.setValueAtTime(150, now);
          osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          osc.start(now);
          osc.stop(now + 0.1);
        } else if (type === "score") {
          osc.type = "sine";
          osc.frequency.setValueAtTime(1000, now);
          osc.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          osc.start(now);
          osc.stop(now + 0.2);
        } else if (type === "hit") {
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(100, now);
          osc.frequency.linearRampToValueAtTime(50, now + 0.1);
          gain.gain.setValueAtTime(0.2, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
          osc.start(now);
          osc.stop(now + 0.3);
        }
      }

      /**
       * Game Objects
       */

      // Background Stars
      const stars = [];
      for (let i = 0; i < 50; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1,
          speed: Math.random() * 0.5 + 0.1,
        });
      }

      function drawBackground() {
        // Deep Space Gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#0f0c29");
        gradient.addColorStop(0.5, "#302b63");
        gradient.addColorStop(1, "#24243e");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Stars
        ctx.fillStyle = "#FFF";
        stars.forEach((star) => {
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
          if (state.current === state.game) {
            star.x -= star.speed;
            if (star.x < 0) star.x = canvas.width;
          }
        });

        // Moon
        ctx.fillStyle = "#eee";
        ctx.shadowBlur = 20;
        ctx.shadowColor = "#fff";
        ctx.beginPath();
        ctx.arc(canvas.width - 100, 100, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Moon Craters
        ctx.fillStyle = "#ddd";
        ctx.beginPath();
        ctx.arc(canvas.width - 110, 90, 8, 0, Math.PI * 2);
        ctx.arc(canvas.width - 85, 110, 12, 0, Math.PI * 2);
        ctx.arc(canvas.width - 105, 120, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      const bird = {
        x: 50,
        y: 150,
        width: 34,
        height: 24,
        velocity: 0,
        gravity: 0.25,
        jumpStrength: 4.6,
        rotation: 0,
        radius: 12, // For circular collision approximation

        draw: function () {
          ctx.save();
          ctx.translate(this.x, this.y);
          // Rotate based on velocity
          this.rotation = Math.min(
            Math.PI / 4,
            Math.max(-Math.PI / 4, this.velocity * 0.1),
          );
          ctx.rotate(this.rotation);

          // Draw Pixel Shiba
          const p = 4; // pixel scale size

          // Colors
          const orange = "#fca311";
          const white = "#ffffff";
          const black = "#000000";
          const pink = "#ff9999";

          // Helper for drawing rects relative to center
          const dr = (c, x, y, w, h) => {
            ctx.fillStyle = c;
            ctx.fillRect(
              x * p - this.width / 2,
              y * p - this.height / 2,
              w * p,
              h * p,
            );
          };

          // Body/Head Shape (Simplified 8-bit style)
          // Ears
          dr(orange, 0, 0, 1, 2);
          dr(orange, 5, 0, 1, 2);

          // Top head
          dr(orange, 1, 1, 4, 1);
          dr(orange, 0, 2, 6, 3);

          // Face White details
          dr(white, 1, 3, 1, 1);
          dr(white, 4, 3, 1, 1);
          dr(white, 1, 4, 4, 2);

          // Eyes
          dr(black, 1, 3, 1, 1);
          dr(black, 4, 3, 1, 1);

          // Nose
          dr(black, 2.5, 4.5, 1, 0.5);

          // Cheeks/Blush
          dr(pink, 0, 3.5, 1, 0.5);
          dr(pink, 5, 3.5, 1, 0.5);

          // Flying scarf (Crypto "To The Moon" Cape)
          if (state.current === state.game) {
            ctx.fillStyle = "#4CAF50"; // Green candle color
            ctx.beginPath();
            ctx.moveTo(-10, 5);
            ctx.lineTo(-25 - Math.sin(frames * 0.2) * 5, 0);
            ctx.lineTo(-25 - Math.sin(frames * 0.2 + 1) * 5, 10);
            ctx.fill();
          }

          ctx.restore();
        },

        update: function () {
          this.velocity += this.gravity;
          this.y += this.velocity;

          // Floor collision
          if (this.y + this.height / 2 >= canvas.height) {
            this.y = canvas.height - this.height / 2;
            gameOver();
          }

          // Ceiling collision (optional, prevents flying over pipes)
          if (this.y < 0) {
            this.y = 0;
            this.velocity = 0;
          }
        },

        jump: function () {
          this.velocity = -this.jumpStrength;
          playSound("jump");
        },

        reset: function () {
          this.y = canvas.height / 2;
          this.velocity = 0;
          this.rotation = 0;
        },
      };

      const pipes = {
        position: [],
        w: 50,
        gap: 170, // Gap between ETH crystals
        dx: 3, // Move speed
        spawnTimer: 0,

        draw: function () {
          for (let i = 0; i < this.position.length; i++) {
            let p = this.position[i];

            // Define pipe boundaries
            let topY = p.y;
            let bottomY = p.y + this.gap;

            // Draw Top ETH Crystal (Stalactite)
            // Main body
            ctx.fillStyle = "#3c3c3d"; // Dark Grey structure
            ctx.fillRect(p.x + 10, 0, this.w - 20, topY - 30);

            // The ETH Logo "Cap" hanging down
            this.drawEthLogo(p.x + this.w / 2, topY - 30, 40, true);

            // Draw Bottom ETH Crystal (Stalagmite)
            // Main body
            ctx.fillStyle = "#3c3c3d";
            ctx.fillRect(
              p.x + 10,
              bottomY + 30,
              this.w - 20,
              canvas.height - bottomY,
            );

            // The ETH Logo "Cap" pointing up
            this.drawEthLogo(p.x + this.w / 2, bottomY + 30, 40, false);
          }
        },

        drawEthLogo: function (cx, cy, size, isTop) {
          // Colors
          const ethLight = "#8C92AC"; // Light grey/blue
          const ethDark = "#3C3C3D"; // Darker
          const ethGlow = "#627EEA"; // Classic ETH blue
          const ethDarkGlow = "#454A75";

          ctx.save();
          ctx.translate(cx, cy);
          if (isTop) {
            // Pointing down
            // Simply drawing a standard ETH logo, but the "pipe" extends upwards from it
            // Let's just draw a large ETH diamond

            // Top half of diamond (Top Triangle)
            ctx.beginPath();
            ctx.moveTo(0, 0); // Center
            ctx.lineTo(-size / 2, -size);
            ctx.lineTo(size / 2, -size);
            ctx.fillStyle = ethGlow;
            ctx.fill();

            // Bottom half of diamond (Bottom Triangle)
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size / 2, -size);
            ctx.lineTo(0, size / 2); // Point
            ctx.lineTo(size / 2, -size);
            ctx.fillStyle = ethDarkGlow;
            ctx.fill();

            // Inner highlights
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -size);
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.stroke();
          } else {
            // Pointing up (Bottom pipe)

            // Top half of diamond
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size / 2, size);
            ctx.lineTo(0, -size / 2); // Point
            ctx.lineTo(size / 2, size);
            ctx.fillStyle = ethGlow;
            ctx.fill();

            // Bottom base
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size / 2, size);
            ctx.lineTo(size / 2, size);
            ctx.fillStyle = ethDarkGlow;
            ctx.fill();
          }
          ctx.restore();
        },

        update: function () {
          // Spawning
          if (frames % 120 === 0) {
            // Approx every 2 seconds
            this.position.push({
              x: canvas.width,
              y: Math.random() * (canvas.height - this.gap - 100) + 50,
            });
          }

          for (let i = 0; i < this.position.length; i++) {
            let p = this.position[i];
            p.x -= this.dx;

            // Collision Detection
            // We use a slightly forgiving hitbox (rectangular)
            // Pipe width is this.w, visual is centered.
            // Hitbox x range: p.x + 10 to p.x + this.w - 10

            let hitX = p.x + 5;
            let hitW = this.w - 10;

            // Bird AABB
            let bx = bird.x - bird.width / 2 + 5; // Padding
            let by = bird.y - bird.height / 2 + 5;
            let bw = bird.width - 10;
            let bh = bird.height - 10;

            // Check x overlap
            if (bx < hitX + hitW && bx + bw > hitX) {
              // Check y overlap (Top pipe OR Bottom pipe)
              // Top Pipe: y < p.y
              // Bottom Pipe: y + bh > p.y + this.gap
              if (by < p.y || by + bh > p.y + this.gap) {
                gameOver();
              }
            }

            // Scoring
            if (p.x + this.w < bird.x && !p.passed) {
              score++;
              scoreDisplay.innerText = score;
              p.passed = true;
              playSound("score");
              // Increase speed slightly every 5 points
              if (score % 5 === 0) this.dx += 0.2;
            }

            // Remove off-screen pipes
            if (p.x + this.w <= 0) {
              this.position.shift();
              i--;
            }
          }
        },

        reset: function () {
          this.position = [];
          this.dx = 3;
        },
      };

      /**
       * Game Control
       */

      function startGame() {
        state.current = state.game;
        score = 0;
        scoreDisplay.innerText = score;
        scoreDisplay.style.display = "block";
        startScreen.style.display = "none";
        gameOverScreen.style.display = "none";
        pipes.reset();
        bird.reset();
        frames = 0;
        loop();
      }

      function gameOver() {
        state.current = state.over;
        playSound("hit");
        scoreDisplay.style.display = "none";
        finalScoreText.innerText = "Score: " + score;
        gameOverScreen.style.display = "block";

        if (score > highScore) {
          highScore = score;
          localStorage.setItem("flappyShibaHighScore", highScore);
        }
      }

      function inputAction(e) {
        if (e.type === "keydown" && e.code !== "Space" && e.code !== "ArrowUp")
          return;
        if (e.type === "keydown") e.preventDefault(); // Stop scrolling

        switch (state.current) {
          case state.getReady:
            startGame();
            break;
          case state.game:
            bird.jump();
            break;
          case state.over:
            // Small cooldown to prevent accidental restarts
            state.current = state.getReady;
            startScreen.style.display = "flex";
            gameOverScreen.style.display = "none";
            bird.reset();
            pipes.reset();
            draw(); // Draw one frame of ready state
            break;
        }
      }

      // Event Listeners
      window.addEventListener("keydown", inputAction);
      window.addEventListener("mousedown", inputAction);
      window.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault(); // Stop zoom/scroll
          inputAction(e);
        },
        { passive: false },
      );

      /**
       * Main Loop
       */

      function draw() {
        drawBackground();
        pipes.draw();

        // Draw Floor (Moon surface)
        ctx.fillStyle = "#666";
        // ctx.fillRect(0, canvas.height - 20, canvas.width, 20); // Removed for full screen aesthetic

        bird.draw();
      }

      function update() {
        bird.update();
        pipes.update();
      }

      function loop() {
        if (state.current === state.game) {
          update();
          draw();
          frames++;
          requestAnimationFrame(loop);
        } else {
          // Draw once if paused/over to maintain visuals
          draw();
        }
      }

      // Initial Draw
      bird.reset();
      draw();
    </script>
  </body>
</html>
